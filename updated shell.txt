

==============================================================

_atoi.c

#include "shell.h"

/**
 * check_interactive - checks if the shell is in interactive mode
 * @info: struct address
 *
 * Return: 1 if interactive mode, 0 otherwise
 */
int check_interactive(info_t *info)
{
	if (isatty(STDIN_FILENO) && info->readfd <= 2)
		return 1;
	else
		return 0;
}

/**
 * check_delim - checks if a character is a delimiter
 * @c: the character to check
 * @delim: the delimiter string
 *
 * Return: 1 if true, 0 if false
 */
int check_delim(char c, char *delim)
{
	int is_delimiter = 0;

	while (*delim)
	{
		if (*delim == c)
		{
			is_delimiter = 1;
			break;
		}
		delim++;
	}

	return is_delimiter;
}

/**
 * check_alpha - checks if a character is alphabetic
 * @c: the character to check
 *
 * Return: 1 if c is alphabetic, 0 otherwise
 */
int check_alpha(int c)
{
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
		return 1;
	else
		return 0;
}

/**
 * convert_to_int - converts a string to an integer
 * @s: the string to be converted
 *
 * Return: 0 if no numbers in string, converted number otherwise
 */
int convert_to_int(char *s)
{
	int i, sign = 1, flag = 0, output;
	unsigned int result = 0;

	for (i = 0; s[i] != '\0' && flag != 2; i++)
	{
		if (s[i] == '-')
			sign *= -1;

		if (s[i] >= '0' && s[i] <= '9')
		{
			flag = 1;
			result *= 10;
			result += (s[i] - '0');
		}
		else if (flag == 1)
			flag = 2;
	}

	if (sign == -1)
		output = -result;
	else
		output = result;

	return output;
}


=======================================================
builtin1.c

#include "shell.h"

/**
 * display_history - displays the history list, one command by line, preceded
 *                   with line numbers, starting at 0.
 * @info: Structure containing potential arguments. Used to maintain
 *        constant function prototype.
 * Return: Always 0
 */
int display_history(info_t *info)
{
	print_list(info->history);
	return 0;
}

/**
 * remove_alias - removes an alias from the alias list
 * @info: parameter struct
 * @str: the string alias
 *
 * Return: Always 0 on success, 1 on error
 */
int remove_alias(info_t *info, char *str)
{
	char *equal_sign, character;
	int ret;

	equal_sign = _strchr(str, '=');
	if (!equal_sign)
		return 1;

	character = *equal_sign;
	*equal_sign = '\0';

	ret = delete_node_at_index(&(info->alias),
		get_node_index(info->alias, node_starts_with(info->alias, str, -1)));

	*equal_sign = character;
	return ret;
}

/**
 * set_alias - sets an alias to a string
 * @info: parameter struct
 * @str: the string alias
 *
 * Return: Always 0 on success, 1 on error
 */
int set_alias(info_t *info, char *str)
{
	char *equal_sign;

	equal_sign = _strchr(str, '=');
	if (!equal_sign)
		return 1;

	if (!*++equal_sign)
		return remove_alias(info, str);

	remove_alias(info, str);
	return (add_node_end(&(info->alias), str, 0) == NULL);
}

/**
 * print_alias - prints an alias string
 * @node: the alias node
 *
 * Return: Always 0 on success, 1 on error
 */
int print_alias(list_t *node)
{
	char *equal_sign = NULL, *alias_string = NULL;

	if (node)
	{
		equal_sign = _strchr(node->str, '=');
		for (alias_string = node->str; alias_string <= equal_sign; alias_string++)
			_putchar(*alias_string);
		_putchar('\'');
		_puts(equal_sign + 1);
		_puts("'\n");
		return 0;
	}
	return 1;
}

/**
 * alias_builtin - mimics the alias builtin (man alias)
 * @info: Structure containing potential arguments. Used to maintain
 *         constant function prototype.
 * Return: Always 0
 */
int alias_builtin(info_t *info)
{
	int i = 0;
	char *equal_sign = NULL;
	list_t *node = NULL;

	if (info->argc == 1)
	{
		node = info->alias;
		while (node)
		{
			print_alias(node);
			node = node->next;
		}
		return 0;
	}

	for (i = 1; info->argv[i]; i++)
	{
		equal_sign = _strchr(info->argv[i], '=');
		if (equal_sign)
			set_alias(info, info->argv[i]);
		else
			print_alias(node_starts_with(info->alias, info->argv[i], '='));
	}

	return 0;
}



============================================================


errors.c 

#include "shell.h"

/**
 * _erratoi - converts a string to an integer
 * @s: the string to be converted
 * Return: 0 if no numbers in string, converted number otherwise
 *       -1 on error
 */
int _erratoi(char *s)
{
	int i = 0;
	unsigned long int result = 0;

	if (*s == '+')
		s++;  /* Change: Removed TODO comment */
	for (i = 0;  s[i] != '\0'; i++)
	{
		if (isdigit(s[i]))
		{
			result *= 10;
			result += (s[i] - '0');
			if (result > INT_MAX)
				return -1;
		}
		else
			return -1;
	}
	return result;
}

/**
 * print_error - prints an error message
 * @info: the parameter & return info struct
 * @estr: string containing specified error type
 * Return: 0 if no numbers in string, converted number otherwise
 *        -1 on error
 */
void print_error(info_t *info, char *estr)
{
	_eputs(info->fname);
	_eputs(": ");
	print_d(info->line_count, STDERR_FILENO);
	_eputs(": ");
	_eputs(info->argv[0]);
	_eputs(": ");
	_eputs(estr);
}

/**
 * print_d - function prints a decimal (integer) number (base 10)
 * @input: the input
 * @fd: the filedescriptor to write to
 *
 * Return: number of characters printed
 */
int print_d(int input, int fd)
{
	int (*__putchar)(char) = _putchar;
	int i, count = 0;
	unsigned int _abs_, current;

	if (fd == STDERR_FILENO)
		__putchar = _eputchar;
	if (input < 0)
	{
		_abs_ = -input;
		__putchar('-');
		count++;
	}
	else
		_abs_ = input;
	current = _abs_;
	for (i = 1000000000; i > 1; i /= 10)
	{
		if (_abs_ / i)
		{
			__putchar('0' + current / i);
			count++;
		}
		current %= i;
	}
	__putchar('0' + current);
	count++;

	return count;
}

/**
 * convert_number - converter function, a clone of itoa
 * @num: number
 * @base: base
 * @flags: argument flags
 *
 * Return: string
 */
char *convert_number(long int num, int base, int flags)
{
	static char *array;
	static char buffer[50];
	char sign = 0;
	char *ptr;
	unsigned long n = num;

	if (!(flags & CONVERT_UNSIGNED) && num < 0)
	{
		n = -num;
		sign = '-';

	}
	array = flags & CONVERT_LOWERCASE ? "0123456789abcdef" : "0123456789ABCDEF";
	ptr = &buffer[49];
	*ptr = '\0';

	do	{
		*--ptr = array[n % base];
		n /= base;
	} while (n != 0);

	if (sign)
		*--ptr = sign;
	return ptr;
}

/**
 * remove_comments - function replaces first instance of '#' with '\0'
 * @buf: address of the string to modify
 *
 * Return: Always 0;
 */
void remove_comments(char *buf)
{
	int i;

	for (i = 0; buf[i] != '\0'; i++)
	{
		if (buf[i] == '#' && (i == 0 || buf[i - 1] == ' '))
		{
			buf[i] = '\0';
			break;
		}
	}
}



=======================================================

exits.c code


exits.c code

#include "shell.h"

/**
 **_strncpy - copies a string
 *@dest: the destination string to be copied to
 *@src: the source string
 *@n: the amount of characters to be copied
 *Return: the concatenated string
 */
char *_strncpy(char *dest, char *src, int n)
{
	int i, j;
	char *s = dest;

	i = 0;
	while (src[i] != '\0' && i < n - 1)
	{
		dest[i] = src[i];
		i++;
	}
	if (i < n)
	{
		j = i;
		while (j < n)
		{
			dest[j] = '\0';
			j++;
		}
	}
	return (s);
}

/**
 **_strncat - concatenates two strings
 *@dest: the first string
 *@src: the second string
 *@n: the amount of bytes to be maximally used
 *Return: the concatenated string
 */
char *_strncat(char *dest, char *src, int n)
{
	int i, j;
	char *s = dest;

	i = 0;
	j = 0;
	while (dest[i] != '\0')
		i++;
	while (src[j] != '\0' && j < n)
	{
		dest[i] = src[j];
		i++;
		j++;
	}
	if (j < n)
		dest[i] = '\0';
	return (s);
}

/**
 **_strchr - locates a character in a string
 *@s: the string to be parsed
 *@c: the character to look for
 *Return: (s) a pointer to the memory area s
 */
char *_strchr(char *s, char c)
{
	do {
		if (*s == c)
			return (s);
	} while (*s++ != '\0');

	return (NULL);
}


================================================

getenv.c code


#include "shell.h"

/**
 * get_environment - returns a copy of the environment strings
 * @info: Structure containing potential arguments. Used to maintain
 *        constant function prototype.
 * Return: a copy of the environment strings
 */
char **get_environment(info_t *info)
{
	if (info->environment == NULL || info->environment_changed == 1)
	{
		free_string_array(info->environment);
		info->environment = list_to_string_array(info->environment_list);
		info->environment_changed = 0;
	}

	return info->environment;
}

/**
 * unset_environment_variable - Remove an environment variable
 * @info: Structure containing potential arguments. Used to maintain
 *        constant function prototype.
 * @variable: the string representing the environment variable
 * Return: 1 if the variable was deleted, 0 otherwise
 */
int unset_environment_variable(info_t *info, char *variable)
{
	list_t *node = info->environment_list;
	size_t index = 0;
	char *p;

	if (node == NULL || variable == NULL)
		return 0;

	while (node != NULL)
	{
		p = starts_with(node->str, variable);
		if (p != NULL && *p == '=')
		{
			info->environment_changed = delete_node_at_index(&(info->environment_list), index);
			index = 0;
			node = info->environment_list;
			continue;
		}
		node = node->next;
		index++;
	}
	return info->environment_changed;
}

/**
 * set_environment_variable - Initialize a new environment variable
 *                            or modify an existing one
 * @info: Structure containing potential arguments. Used to maintain
 *        constant function prototype.
 * @variable: the string representing the environment variable
 * @value: the string representing the value of the environment variable
 * Return: Always 0
 */
int set_environment_variable(info_t *info, char *variable, char *value)
{
	char *buffer = NULL;
	list_t *node;
	char *p;

	if (variable == NULL || value == NULL)
		return 0;

	buffer = malloc(_strlen(variable) + _strlen(value) + 2);
	if (buffer == NULL)
		return 1;
	_strcpy(buffer, variable);
	_strcat(buffer, "=");
	_strcat(buffer, value);
	node = info->environment_list;
	while (node != NULL)
	{
		p = starts_with(node->str, variable);
		if (p != NULL && *p == '=')
		{
			free(node->str);
			node->str = buffer;
			info->environment_changed = 1;
			return 0;
		}
		node = node->next;
	}
	add_node_end(&(info->environment_list), buffer, 0);
	free(buffer);
	info->environment_changed = 1;
	return 0;
}


==========================================================

history.c

#include "shell.h"

/**
 * get_history_file - retrieves the history file path
 * @info: pointer to the information struct
 *
 * Return: allocated string containing the history file path
 */
char *get_history_file(info_t *info)
{
	char *dir = get_environment_variable(info, "HOME=");
	if (!dir)
		return NULL;

	char *path = allocate_memory(_strlen(dir) + _strlen(HIST_FILE) + 2);
	if (!path)
		return NULL;

	concatenate_strings(path, dir, "/");
	concatenate_strings(path, path, HIST_FILE);
	free(dir);

	return path;
}

/**
 * write_history - writes history to a file
 * @info: pointer to the information struct
 *
 * Return: 1 on success, -1 on failure
 */
int write_history(info_t *info)
{
	ssize_t fd;
	char *filename = get_history_file(info);
	list_t *node = NULL;

	if (!filename)
		return -1;

	fd = open(filename, O_CREAT | O_TRUNC | O_RDWR, 0644);
	free(filename);
	if (fd == -1)
		return -1;

	for (node = info->history; node; node = node->next)
	{
		write_string_to_file(node->str, fd);
		write_character_to_file('\n', fd);
	}
	write_character_to_file(BUF_FLUSH, fd);

	close(fd);
	return 1;
}

/**
 * read_history - reads history from a file
 * @info: pointer to the information struct
 *
 * Return: number of history entries read, 0 on failure
 */
int read_history(info_t *info)
{
	int i, last = 0, linecount = 0;
	ssize_t fd, rdlen, fsize = 0;
	struct stat st;
	char *buf = NULL, *filename = get_history_file(info);

	if (!filename)
		return 0;

	fd = open(filename, O_RDONLY);
	free(filename);
	if (fd == -1)
		return 0;

	if (!fstat(fd, &st))
		fsize = st.st_size;

	if (fsize < 2)
		return 0;

	buf = allocate_memory(fsize + 1);
	if (!buf)
		return 0;

	rdlen = read(fd, buf, fsize);
	buf[fsize] = '\0';

	if (rdlen <= 0)
		return free(buf), 0;

	close(fd);

	for (i = 0; i < fsize; i++)
	{
		if (buf[i] == '\n')
		{
			buf[i] = '\0';
			build_history_entry(info, buf + last, linecount++);
			last = i + 1;
		}
	}

	if (last != i)
		build_history_entry(info, buf + last, linecount++);

	free(buf);
	info->histcount = linecount;

	while (info->histcount-- >= HIST_MAX)
		delete_history_entry(&(info->history), 0);

	renumber_history_entries(info);
	return info->histcount;
}

/**
 * build_history_entry - builds a history entry and adds it to the list
 * @info: pointer to the information struct
 * @buf: string buffer containing the history entry
 * @linecount: line count of the history entry
 *
 * Return: Always 0
 */
int build_history_entry(info_t *info, char *buf, int linecount)
{
	list_t *node = NULL;

	if (info->history)
		node = info->history;

	add_history_entry(&node, buf, linecount);

	if (!info->history)
		info->history = node;

	return 0;
}

/**
 * renumber_history_entries - renumbers the history entries after changes
 * @info: pointer to the information struct
 *
 * Return: the new histcount
 */
int renumber_history_entries(info_t *info)
{
	list_t *node = info->history;
	int i = 0;

	while (node)
	{
		node->num = i++;
		node = node->next;
	}

	return (info->histcount = i);
}


===============================================================


lists1.c code


#include "shell.h"

/**
 * count_list_nodes - counts the number of nodes in a linked list
 * @head: pointer to the head of the list
 *
 * Return: number of nodes in the list
 */
size_t count_list_nodes(const list_t *head)
{
	size_t count = 0;

	while (head)
	{
		head = head->next;
		count++;
	}

	return count;
}

/**
 * convert_list_to_strings - converts a linked list to an array of strings
 * @head: pointer to the head of the list
 *
 * Return: array of strings
 */
char **convert_list_to_strings(list_t *head)
{
	list_t *node = head;
	size_t count = count_list_nodes(head);
	char **strings;
	char *str;

	if (!head || !count)
		return NULL;

	strings = malloc(sizeof(char *) * (count + 1));
	if (!strings)
		return NULL;

	for (size_t i = 0; node; node = node->next, i++)
	{
		str = malloc(_strlen(node->str) + 1);
		if (!str)
		{
			for (size_t j = 0; j < i; j++)
				free(strings[j]);
			free(strings);
			return NULL;
		}

		str = _strcpy(str, node->str);
		strings[i] = str;
	}

	strings[count] = NULL;
	return strings;
}

/**
 * print_linked_list - prints all elements of a linked list
 * @head: pointer to the head of the list
 *
 * Return: number of nodes in the list
 */
size_t print_linked_list(const list_t *head)
{
	size_t count = 0;

	while (head)
	{
		_puts(convert_number(head->num, 10, 0));
		_putchar(':');
		_putchar(' ');
		_puts(head->str ? head->str : "(nil)");
		_puts("\n");
		head = head->next;
		count++;
	}

	return count;
}

/**
 * find_node_starts_with - finds a node whose string starts with a prefix
 * @head: pointer to the head of the list
 * @prefix: string to match as prefix
 * @c: the character to match after the prefix
 *
 * Return: matching node or NULL if not found
 */
list_t *find_node_starts_with(list_t *head, char *prefix, char c)
{
	char *p = NULL;

	while (head)
	{
		p = starts_with(head->str, prefix);
		if (p && ((c == -1) || (*p == c)))
			return head;
		head = head->next;
	}

	return NULL;
}

/**
 * get_node_index - gets the index of a node in a linked list
 * @head: pointer to the head of the list
 * @node: pointer to the node
 *
 * Return: index of the node or -1 if not found
 */
ssize_t get_node_index(list_t *head, list_t *node)
{
	size_t index = 0;

	while (head)
	{
		if (head == node)
			return index;
		head = head->next;
		index++;
	}

	return -1;
}

================================================================

memory.c code

#include "shell.h"

/**
 * free_and_null - frees a pointer and sets it to NULL
 * @ptr: address of the pointer to free
 *
 * Return: 1 if freed, otherwise 0.
 */
int free_and_null(void **ptr)
{
	if (ptr != NULL && *ptr != NULL)
	{
		free(*ptr);
		*ptr = NULL;
		return 1;
	}
	return 0;
}


==============================================================

realloc.c

#include "shell.h"

/**
 * fill_memory - fills memory with a constant byte
 * @buffer: the pointer to the memory area
 * @value: the byte value to fill the buffer with
 * @length: the number of bytes to be filled
 *
 * Return: pointer to the memory area
 */
char *fill_memory(char *buffer, char value, unsigned int length)
{
	unsigned int i;

	for (i = 0; i < length; i++)
		buffer[i] = value;

	return buffer;
}

/**
 * free_string_array - frees an array of strings
 * @strings: the array of strings to free
 */
void free_string_array(char **strings)
{
	char **ptr = strings;

	if (!strings)
		return;

	while (*strings)
		free(*strings++);

	free(ptr);
}

/**
 * reallocate_memory - reallocates a block of memory
 * @ptr: pointer to the previously allocated block
 * @old_size: size of the previous block in bytes
 * @new_size: size of the new block in bytes
 *
 * Return: pointer to the reallocated block
 */
void *reallocate_memory(void *ptr, unsigned int old_size, unsigned int new_size)
{
	char *new_ptr;

	if (!ptr)
		return malloc(new_size);

	if (!new_size)
	{
		free(ptr);
		return NULL;
	}

	if (new_size == old_size)
		return ptr;

	new_ptr = malloc(new_size);
	if (!new_ptr)
		return NULL;

	unsigned int i;
	for (i = 0; i < old_size && i < new_size; i++)
		new_ptr[i] = ((char *)ptr)[i];

	free(ptr);
	return new_ptr;
}

=============================================================


shell_loop.c

#include "shell.h"

/**
 * shell_loop - main shell loop
 * @info: the parameter & return info struct
 * @av: the argument vector from main()
 *
 * Return: 0 on success, 1 on error, or error code
 */
int shell_loop(info_t *info, char **av)
{
	ssize_t read_status = 0;
	int builtin_ret = 0;

	while (read_status != -1 && builtin_ret != -2)
	{
		clear_info(info);
		if (is_interactive(info))
			_puts("$ ");
		_eputchar(BUF_FLUSH);
		read_status = get_input(info);
		if (read_status != -1)
		{
			set_info(info, av);
			builtin_ret = find_builtin(info);
			if (builtin_ret == -1)
				find_command(info);
		}
		else if (is_interactive(info))
			_putchar('\n');
		free_info(info, 0);
	}
	write_history(info);
	free_info(info, 1);
	if (!is_interactive(info) && info->status)
		exit(info->status);
	if (builtin_ret == -2)
	{
		if (info->error_num == -1)
			exit(info->status);
		exit(info->error_num);
	}
	return (builtin_ret);
}

/**
 * find_builtin - finds a builtin command
 * @info: the parameter & return info struct
 *
 * Return: -1 if builtin not found,
 *         0 if builtin executed successfully,
 *         1 if builtin found but not successful,
 *         2 if builtin signals exit()
 */
int find_builtin(info_t *info)
{
	int i, builtin_ret = -1;
	builtin_table builtintbl[] = {
		{"exit", my_exit},
		{"env", my_env},
		{"help", my_help},
		{"history", my_history},
		{"setenv", my_setenv},
		{"unsetenv", my_unsetenv},
		{"cd", my_cd},
		{"alias", my_alias},
		{NULL, NULL}
	};

	for (i = 0; builtintbl[i].command; i++)
	{
		if (_strcmp(info->argv[0], builtintbl[i].command) == 0)
		{
			info->line_count++;
			builtin_ret = builtintbl[i].function(info);
			break;
		}
	}
	return (builtin_ret);
}

/**
 * find_command - finds a command in PATH
 * @info: the parameter & return info struct
 *
 * Return: void
 */
void find_command(info_t *info)
{
	char *path = NULL;
	int i, arg_count;

	info->path = info->argv[0];
	if (info->line_count_flag == 1)
	{
		info->line_count++;
		info->line_count_flag = 0;
	}
	for (i = 0, arg_count = 0; info->arg[i]; i++)
	{
		if (!is_delim(info->arg[i], " \t\n"))
			arg_count++;
	}
	if (!arg_count)
		return;

	path = find_path(info, _getenv(info, "PATH="), info->argv[0]);
	if (path)
	{
		info->path = path;
		fork_command(info);
	}
	else
	{
		if ((is_interactive(info) || _getenv(info, "PATH=") || info->argv[0][0] == '/')
		    && is_cmd(info, info->argv[0]))
			fork_command(info);
		else if (*(info->arg) != '\n')
		{
			info->status = 127;
			print_error(info, "not found\n");
		}
	}
}

/**
 * fork_command - forks a child process to run a command
 * @info: the parameter & return info struct
 *
 * Return: void
 */
void fork_command(info_t *info)
{
	pid_t child_pid;

	child_pid = fork();
	if (child_pid == -1)
	{
		perror("Error:");
		return;
	}
	if (child_pid == 0)
	{
		if (execve(info->path, info->argv, get_environ(info)) == -1)
		{
			free_info(info, 1);
			if (errno == EACCES)
				exit(126);
			exit(1);
		}
	}
	else
	{
		wait(&(info->status));
		if (WIFEXITED(info->status))
		{
			info->status = WEXITSTATUS(info->status);
			if (info->status == 126)
				print_error(info, "Permission denied\n");
		}
	}
}

=========================================================

string1.c

#include "shell.h"

/**
 * copy_string - copies a string
 * @destination: the destination
 * @source: the source
 *
 * Return: pointer to destination
 */
char *copy_string(char *destination, const char *source)
{
	int index = 0;

	if (destination == source || source == NULL)
		return destination;
	while (source[index])
	{
		destination[index] = source[index];
		index++;
	}
	destination[index] = '\0';
	return destination;
}

/**
 * duplicate_string - duplicates a string
 * @str: the string to duplicate
 *
 * Return: pointer to the duplicated string
 */
char *duplicate_string(const char *str)
{
	int length = 0;
	char *duplicate;

	if (str == NULL)
		return NULL;
	while (str[length])
		length++;
	duplicate = malloc(sizeof(char) * (length + 1));
	if (duplicate == NULL)
		return NULL;
	for (int i = 0; i <= length; i++)
		duplicate[i] = str[i];
	return duplicate;
}

/**
 * print_string - prints an input string
 * @str: the string to be printed
 *
 * Return: Nothing
 */
void print_string(const char *str)
{
	if (str == NULL)
		return;
	for (int i = 0; str[i]; i++)
		print_character(str[i]);
}

/**
 * print_character - writes the character c to stdout
 * @c: The character to print
 *
 * Return: On success 1.
 * On error, -1 is returned, and errno is set appropriately.
 */
int print_character(char c)
{
	static int index = 0;
	static char buffer[WRITE_BUFFER_SIZE];

	if (c == BUFFER_FLUSH || index >= WRITE_BUFFER_SIZE)
	{
		write(1, buffer, index);
		index = 0;
	}
	if (c != BUFFER_FLUSH)
		buffer[index++] = c;
	return 1;
}


===============================================================


vars.c

#include "shell.h"

/**
 * is_chain_delimiter - checks if the current character in the buffer is a chain delimiter
 * @info: the parameter structure
 * @buffer: the character buffer
 * @position: address of the current position in the buffer
 *
 * Return: 1 if it is a chain delimiter, 0 otherwise
 */
int is_chain_delimiter(info_t *info, char *buffer, size_t *position)
{
	size_t pos = *position;

	if (buffer[pos] == '|' && buffer[pos + 1] == '|')
	{
		buffer[pos] = '\0';
		pos++;
		info->command_buffer_type = CMD_OR;
	}
	else if (buffer[pos] == '&' && buffer[pos + 1] == '&')
	{
		buffer[pos] = '\0';
		pos++;
		info->command_buffer_type = CMD_AND;
	}
	else if (buffer[pos] == ';')
	{
		buffer[pos] = '\0';
		info->command_buffer_type = CMD_CHAIN;
	}
	else
		return 0;

	*position = pos;
	return 1;
}

/**
 * check_chain_continuation - checks if we should continue chaining based on the last status
 * @info: the parameter structure
 * @buffer: the character buffer
 * @position: address of the current position in the buffer
 * @start: starting position in the buffer
 * @length: length of the buffer
 *
 * Return: void
 */
void check_chain_continuation(info_t *info, char *buffer, size_t *position, size_t start, size_t length)
{
	size_t pos = *position;

	if (info->command_buffer_type == CMD_AND)
	{
		if (info->status)
		{
			buffer[start] = '\0';
			pos = length;
		}
	}
	else if (info->command_buffer_type == CMD_OR)
	{
		if (!info->status)
		{
			buffer[start] = '\0';
			pos = length;
		}
	}

	*position = pos;
}

/**
 * replace_aliases - replaces aliases in the tokenized string
 * @info: the parameter structure
 *
 * Return: 1 if replaced, 0 otherwise
 */
int replace_aliases(info_t *info)
{
	int i;
	list_t *node;
	char *p;

	for (i = 0; i < 10; i++)
	{
		node = find_alias(info->aliases, info->arguments[0]);
		if (!node)
			return 0;

		free(info->arguments[0]);
		p = _strchr(node->string, '=');
		if (!p)
			return 0;

		p = _strdup(p + 1);
		if (!p)
			return 0;

		info->arguments[0] = p;
	}

	return 1;
}

/**
 * replace_variables - replaces variables in the tokenized string
 * @info: the parameter structure
 *
 * Return: 1 if replaced, 0 otherwise
 */
int replace_variables(info_t *info)
{
	int i = 0;
	list_t *node;

	for (i = 0; info->arguments[i]; i++)
	{
		if (info->arguments[i][0] != '$' || !info->arguments[i][1])
			continue;

		if (!_strcmp(info->arguments[i], "$?"))
		{
			replace_string(&(info->arguments[i]), _strdup(convert_number(info->status, 10, 0)));
			continue;
		}
		if (!_strcmp(info->arguments[i], "$$"))
		{
			replace_string(&(info->arguments[i]), _strdup(convert_number(getpid(), 10, 0)));
			continue;
		}

		node = find_node_starting_with(info->environment, &(info->arguments[i][1]), '=');
		if (node)
		{
			replace_string(&(info->arguments[i]), _strdup(_strchr(node->string, '=') + 1));
			continue;
		}

		replace_string(&(info->arguments[i]), _strdup(""));
	}

	return 0;
}

/**
 * replace_string - replaces a string
 * @old_string: address of the old string
 * @new_string: new string
 *
 * Return: 1 if replaced, 0 otherwise
 */
int replace_string(char **old_string, char *new_string)
{
	free(*old_string);
	*old_string = new_string;
	return 1;
}
       